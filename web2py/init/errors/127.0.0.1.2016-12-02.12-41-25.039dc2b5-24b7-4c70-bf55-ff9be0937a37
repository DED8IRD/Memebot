(dp1
S'output'
p2
S"<type 'exceptions.NameError'> global name '_image_generator__get_src_img' is not defined"
p3
sS'layer'
p4
S'/cygdrive/c/web2py/applications/start/controllers/api.py'
p5
sS'code'
p6
S'import json\nimport os\nfrom generator import sentGenerator\nfrom image_generator import image_generator\n\ndef generate_text():\n    """\n    nlg text gen\n    """\n    file_path = os.path.join(request.folder, \'static\', \'json\', \'post_compilation.json\')\n    with open(file_path) as post_comp:\n        ngrams = json.load(post_comp)\n    generated = (sentGenerator(ngrams))().encode(\'utf-8\')\n\n    p_id = db.shitpost.insert(\n        text_post=generated\n    )\n    p = db.shitpost(p_id)\n    return response.json(dict(post=p))\n\n\ndef generate_image():\n    """\n    Generates original image\n    """\n    bkgd_path = os.path.join(request.folder, \'static\', \'images\', \'src\', \'bkgd\')\n    back_overlay_path = os.path.join(request.folder, \'static\', \'images\', \'src\', \'back overlays\')\n    overlay_path = os.path.join(request.folder, \'static\', \'images\', \'src\')\n    vector_path = os.path.join(request.folder, \'static\', \'images\', \'src\', \'vectors\')\n    dest_path = os.path.join(request.folder, \'static\', \'images\', \'gen\')\n    gen = image_generator(bkgd_path, back_overlay_path, overlay_path, vector_path, dest_path)\n    p_id = db.shitpost.insert(\n        image_url=gen()\n    )\n\n\n# These are the controllers for your ajax api.\ndef get_posts():\n    """This controller is used to get the posts.  Follow what we did in lecture 10, to ensure\n    that the first time, we get 4 posts max, and each time the "load more" button is pressed,\n    we load at most 4 more posts."""\n    start_idx = int(request.vars.start_idx) if request.vars.start_idx is not None else 0\n    end_idx = int(request.vars.end_idx) if request.vars.end_idx is not None else 0\n    # We just generate a lot of of data.\n    posts = []\n    has_more = False\n    rows = db().select(db.shitpost.ALL, orderby=~db.shitpost.created_on, limitby=(start_idx, end_idx + 1))\n    for i, r in enumerate(rows):\n        if i < end_idx - start_idx:\n            posts.append(r)\n        else:\n            has_more = True\n    logged_in = auth.user_id is not None\n    return response.json(dict(\n        posts=posts,\n        logged_in=logged_in,\n        has_more=has_more,\n    ))\n\n\n# Note that we need the URL to be signed, as this changes the db.\n@auth.requires_signature()\ndef add_post():\n    """Here you get a new post and add it.  Return what you want."""\n    p_id = db.post.insert(\n        post_content=request.vars.post_content\n    )\n    p = get_post_output(db.post(p_id))\n    return response.json(dict(post=p))\n\n\n@auth.requires_signature()\ndef del_post():\n    """Used to delete a post."""\n    post = db.post[request.vars.post_id]\n    if not auth.user or post.user_email != auth.user.email:\n        return "no"\n    db(db.post.id == request.vars.post_id).delete()\n    return "ok"\n\n\n@auth.requires_signature()\ndef edit_post():\n    """Used to edit a post."""\n    post = db.post[request.vars.post_id]\n    if not auth.user or post.user_email != auth.user.email:\n        return "no"\n    db(db.post.id == request.vars.post_id).update(post_content = request.vars.post_content)\n    return "{0}{1}".format("Edited On ", post.updated_on)\n\n\n# Utility functions\ndef get_user_name_from_email(email):\n    """Returns a string corresponding to the user first and last names,\n    given the user email."""\n    u = db(db.auth_user.email == email).select().first()\n    if u is None:\n        return \'None\'\n    else:\n        return \' \'.join([u.first_name, u.last_name])\n\n\ndef get_post_output(post):\n    id = post.id\n    user_email = post.user_email\n    post_content = post.post_content\n    user_name = get_user_name_from_email(user_email)\n    created_on = post.created_on\n    updated = post.created_on != post.updated_on\n    updated_on = "" if not updated else "{0}{1}".format("Edited On ", post.updated_on)\n    is_mine = auth.user and user_email == auth.user.email\n    return dict(\n                id=id,\n                user_email=user_email,\n                post_content=post_content,\n                user_name=user_name,\n                created_on=created_on,\n                updated=updated,\n                updated_on=updated_on,\n                is_mine=is_mine,\n            )\n\nresponse._vars=response._caller(generate_image)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/cygdrive/c/web2py/gluon/restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "/cygdrive/c/web2py/applications/start/controllers/api.py", line 123, in <module>\n  File "/cygdrive/c/web2py/gluon/globals.py", line 417, in <lambda>\n    self._caller = lambda f: f()\n  File "/cygdrive/c/web2py/applications/start/controllers/api.py", line 33, in generate_image\n    image_url=gen()\n  File "applications/start/modules/image_generator.py", line 26, in __call__\n    def __generate(self):\nNameError: global name \'_image_generator__get_src_img\' is not defined\n'
p11
s.