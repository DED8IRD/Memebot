(dp1
S'output'
p2
S"<type 'exceptions.LookupError'> \n**********************************************************************\n  Resource u'corpora/stopwords' not found.  Please use the NLTK\n  Downloader to obtain the resource:  >>> nltk.download()\n  Searched in:\n    - 'C:\\\\Users\\\\james/nltk_data'\n    - 'C:\\\\nltk_data'\n    - 'D:\\\\nltk_data'\n    - 'E:\\\\nltk_data'\n    - 'C:\\\\Program Files\\\\Anaconda2\\\\nltk_data'\n    - 'C:\\\\Program Files\\\\Anaconda2\\\\lib\\\\nltk_data'\n    - 'C:\\\\Users\\\\james\\\\AppData\\\\Roaming\\\\nltk_data'\n**********************************************************************"
p3
sS'layer'
p4
S'C:\\Users\\james\\PycharmProjects\\cmps183\\web2py\\applications\\start\\controllers/api.py'
p5
sS'code'
p6
S'import json\nimport os\n\nfrom applications.start.modules.generator import sentGenerator\n\n\ndef generate_text():\n    """\n    nlg text gen\n    """\n    file_path = os.path.join(request.folder, \'static\', \'json\', \'post_compilation.json\')\n    with open(file_path) as post_comp:\n        ngrams = json.load(post_comp)\n    gen = sentGenerator(ngrams)\n    return gen().encode(\'utf-8\')\n\n\n# These are the controllers for your ajax api.\ndef get_posts():\n    """This controller is used to get the posts.  Follow what we did in lecture 10, to ensure\n    that the first time, we get 4 posts max, and each time the "load more" button is pressed,\n    we load at most 4 more posts."""\n    start_idx = int(request.vars.start_idx) if request.vars.start_idx is not None else 0\n    end_idx = int(request.vars.end_idx) if request.vars.end_idx is not None else 0\n    # We just generate a lot of of data.\n    posts = []\n    has_more = False\n    rows = db().select(db.post.ALL, orderby=~db.post.created_on, limitby=(start_idx, end_idx + 1))\n    for i, r in enumerate(rows):\n        if i < end_idx - start_idx:\n            p = get_post_output(r)\n            posts.append(p)\n        else:\n            has_more = True\n    logged_in = auth.user_id is not None\n    return response.json(dict(\n        posts=posts,\n        logged_in=logged_in,\n        has_more=has_more,\n    ))\n\n\n# Note that we need the URL to be signed, as this changes the db.\n@auth.requires_signature()\ndef add_post():\n    """Here you get a new post and add it.  Return what you want."""\n    p_id = db.post.insert(\n        post_content=request.vars.post_content\n    )\n    p = get_post_output(db.post(p_id))\n    return response.json(dict(post=p))\n\n\n@auth.requires_signature()\ndef del_post():\n    """Used to delete a post."""\n    post = db.post[request.vars.post_id]\n    if not auth.user or post.user_email != auth.user.email:\n        return "no"\n    db(db.post.id == request.vars.post_id).delete()\n    return "ok"\n\n\n@auth.requires_signature()\ndef edit_post():\n    """Used to edit a post."""\n    post = db.post[request.vars.post_id]\n    if not auth.user or post.user_email != auth.user.email:\n        return "no"\n    db(db.post.id == request.vars.post_id).update(post_content = request.vars.post_content)\n    return "{0}{1}".format("Edited On ", post.updated_on)\n\n\n# Utility functions\ndef get_user_name_from_email(email):\n    """Returns a string corresponding to the user first and last names,\n    given the user email."""\n    u = db(db.auth_user.email == email).select().first()\n    if u is None:\n        return \'None\'\n    else:\n        return \' \'.join([u.first_name, u.last_name])\n\n\ndef get_post_output(post):\n    id = post.id\n    user_email = post.user_email\n    post_content = post.post_content\n    user_name = get_user_name_from_email(user_email)\n    created_on = post.created_on\n    updated = post.created_on != post.updated_on\n    updated_on = "" if not updated else "{0}{1}".format("Edited On ", post.updated_on)\n    is_mine = auth.user and user_email == auth.user.email\n    return dict(\n                id=id,\n                user_email=user_email,\n                post_content=post_content,\n                user_name=user_name,\n                created_on=created_on,\n                updated=updated,\n                updated_on=updated_on,\n                is_mine=is_mine,\n            )\n\nresponse._vars=response._caller(generate_text)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "C:\\Users\\james\\PycharmProjects\\cmps183\\web2py\\gluon\\restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "C:\\Users\\james\\PycharmProjects\\cmps183\\web2py\\applications\\start\\controllers/api.py", line 4, in <module>\n    from applications.start.modules.generator import sentGenerator\n  File "C:\\Users\\james\\PycharmProjects\\cmps183\\web2py\\gluon\\custom_import.py", line 108, in custom_importer\n    return NATIVE_IMPORTER(name, globals, locals, fromlist, level)\n  File "applications\\start\\modules\\generator.py", line 16, in <module>\n    STOPWORDS = nltk.corpus.stopwords.words(\'english\')\n  File "C:\\Program Files\\Anaconda2\\lib\\site-packages\\nltk\\corpus\\util.py", line 99, in __getattr__\n    self.__load()\n  File "C:\\Program Files\\Anaconda2\\lib\\site-packages\\nltk\\corpus\\util.py", line 64, in __load\n    except LookupError: raise e\nLookupError: \n**********************************************************************\n  Resource u\'corpora/stopwords\' not found.  Please use the NLTK\n  Downloader to obtain the resource:  >>> nltk.download()\n  Searched in:\n    - \'C:\\\\Users\\\\james/nltk_data\'\n    - \'C:\\\\nltk_data\'\n    - \'D:\\\\nltk_data\'\n    - \'E:\\\\nltk_data\'\n    - \'C:\\\\Program Files\\\\Anaconda2\\\\nltk_data\'\n    - \'C:\\\\Program Files\\\\Anaconda2\\\\lib\\\\nltk_data\'\n    - \'C:\\\\Users\\\\james\\\\AppData\\\\Roaming\\\\nltk_data\'\n**********************************************************************\n'
p11
s.