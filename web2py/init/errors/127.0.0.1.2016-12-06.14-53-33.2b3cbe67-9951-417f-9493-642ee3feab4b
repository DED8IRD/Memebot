(dp1
S'output'
p2
S"<type 'exceptions.NameError'> global name 'r' is not defined"
p3
sS'layer'
p4
S'/cygdrive/c/web2py/applications/init/controllers/api.py'
p5
sS'code'
p6
S'from __future__ import unicode_literals\nimport json\nimport os\nfrom generator import sentGenerator\nfrom image_generator import image_generator\n\n\ndef generate_text():\n    """\n    nlg text gen\n    """\n    file_path = os.path.join(request.folder, \'static\', \'json\', \'post_compilation.json\')\n    with open(file_path) as post_comp:\n        ngrams = json.load(post_comp)\n        gen = sentGenerator(ngrams)\n        return gen().encode(\'utf-8\')\n\n\ndef generate_image():\n    """\n    Generates original image\n    """\n    bkgd_path = os.path.join(request.folder, \'static\', \'images\', \'src\', \'bkgd\')\n    back_overlay_path = os.path.join(request.folder, \'static\', \'images\', \'src\', \'back overlays\')\n    overlay_path = os.path.join(request.folder, \'static\', \'images\', \'src\')\n    vector_path = os.path.join(request.folder, \'static\', \'images\', \'src\', \'vectors\')\n    dest_path = os.path.join(request.folder, \'static\', \'images\', \'gen\')\n    gen = image_generator(bkgd_path, back_overlay_path, overlay_path, vector_path, dest_path)\n    return gen()\n\n\ndef generate_post():\n    p_id = db.shitpost.insert(\n        text_post = generate_text(),\n        image = generate_image()\n    )\n    p = db.shitpost(p_id)\n    return response.json(dict(post=p))\n\n\n# These are the controllers for your ajax api.\ndef get_posts():\n    """This controller is used to get the posts.  Follow what we did in lecture 10, to ensure\n    that the first time, we get 4 posts max, and each time the "load more" button is pressed,\n    we load at most 4 more posts."""\n    start_idx = int(request.vars.start_idx) if request.vars.start_idx is not None else 0\n    end_idx = int(request.vars.end_idx) if request.vars.end_idx is not None else 0\n    # We just generate a lot of of data.\n    posts = []\n    has_more = False\n    rows = db().select(db.shitpost.ALL, orderby=~db.shitpost.created_on, limitby=(start_idx, end_idx + 1))\n    for i, r in enumerate(rows):\n        if i < end_idx - start_idx:\n            posts.append(r)\n            comments = db(db.post_comment.shitpost==r.id).select(db.post_comment.ALL, orderby=~db.post_comment.created_on, limitby=(0,4))\n        else:\n            has_more = True\n    logged_in = auth.user_id is not None\n    return response.json(dict(\n        posts=posts,\n        logged_in=logged_in,\n        has_more=has_more\n    ))\n\n\ndef get_best_posts():\n    posts = []\n    rows = db().select(db.shitpost.ALL, orderby=~db.shitpost.upvotes, limitby=(0, 25))\n    for row in enumerate(rows):\n        posts.append(r)\n    logged_in = auth.user_id is not None\n    return response.json(dict(\n        posts=posts,\n        logged_in=logged_in\n    ))\n\n\ndef view_post():\n    post = db.shitpost[request.args(0)] or redirect(URL(r=request, f=\'index\'))\n    list = db(db.post_comment.shitpost==post.id).select(db.post_comment.ALL)\n    comments = []\n    logged_in = auth.user_id is not None\n    for comment in list:\n        comments.append(get_comment_output(comment))\n    return response.json(dict(\n        post=post,\n        comments=comments,\n        logged_in=logged_in\n    ))\n\n\n# Note that we need the URL to be signed, as this changes the db.\n# @auth.requires_signature()\ndef add_comment():\n    """Here you get a new post and add it.  Return what you want."""\n    post = db.shitpost[request.args(0)] or redirect(URL(r=request, f=\'index\'))\n    c_id =  db.post_comment.insert(\n        shitpost=post.id,\n        comment_content=request.vars.comment_content\n    )\n    c = get_comment_output(db.post_comment(c_id))\n    return response.json(dict(comment=c))\n\n\n@auth.requires_signature()\ndef del_comment():\n    """Used to delete a comment."""\n    comment = db.post_comment[request.vars.comment_id]\n    if not auth.user or comment.user_email != auth.user.email:\n        return "no"\n    db( db.post_comment.id == request.vars.comment_id).delete()\n    return "ok"\n\n\n@auth.requires_signature()\ndef edit_comment():\n    """Used to edit a comment."""\n    comment = db.post_comment[request.vars.comment_id]\n    if not auth.user or comment.user_email != auth.user.email:\n        return "no"\n    db( db.post_comment.id == request.vars.comment_id).update(comment_content = request.vars.comment_content)\n    return "{0}{1}".format("Edited On ", comment.updated_on)\n\n\n@auth.requires_signature()\ndef vote():\n    """Used to vote on a post."""\n    if not auth.user:\n        return response.json(dict(\n            success="no"\n        ))\n    post = db.shitpost[request.vars.post_id]\n    list = db(db.votelog.shitpost == post.id).select(db.votelog.ALL)\n    my_vote = None\n    for vote in list:\n        if vote.user_email == auth.user.email:\n            my_vote = vote\n\n    success = False\n    new_value = post.upvotes\n    vote_value = int(request.vars.vote_value)\n\n    # Vote\n    if my_vote is None:\n        v_id = db.votelog.insert(\n            shitpost = post,\n            is_upvote = True if vote_value == 1 else False\n        )\n        new_value = post.upvotes + vote_value\n        db(db.shitpost.id == post.id).update(upvotes = new_value)\n        v = db.votelog(v_id)\n        success = True\n    else:\n        # Delete vote\n        if (my_vote.is_upvote and vote_value == 1) or \\\n           (not my_vote.is_upvote and vote_value == -1):\n            db(db.votelog.id == my_vote.id).delete()\n            new_value = post.upvotes - vote_value\n            db(db.shitpost.id == post.id).update(upvotes=new_value)\n            success = True\n\n    if success:\n        return response.json(dict(\n            success="yes",\n            count = new_value\n        ))\n    return response.json(dict(\n        success="no"\n    ))\n\n\n# Utility functions\ndef get_user_name_from_email(email):\n    """Returns a string corresponding to the user first and last names,\n    given the user email."""\n    u = db(db.auth_user.email == email).select().first()\n    if u is None:\n        return \'None\'\n    else:\n        return \' \'.join([u.first_name, u.last_name])\n\n\ndef get_comment_output(comment):\n    id = comment.id\n    shitpost_id = comment.shitpost\n    user_email = comment.user_email\n    comment_content = comment.comment_content\n    user_name = (comment.username if comment.username is not None \\\n                 else get_user_name_from_email(user_email))\n    created_on = comment.created_on\n    updated = comment.created_on != comment.updated_on\n    updated_on = "" if not updated else "{0}{1}".format("Edited On ", comment.updated_on)\n    is_mine = auth.user and user_email == auth.user.email\n    return dict(\n                id=id,\n                shitpost=shitpost_id,\n                user_email=user_email,\n                comment_content=comment_content,\n                user_name=user_name,\n                created_on=created_on,\n                updated=updated,\n                updated_on=updated_on,\n                is_mine=is_mine\n            )\n\nresponse._vars=response._caller(get_best_posts)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/cygdrive/c/web2py/gluon/restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "/cygdrive/c/web2py/applications/init/controllers/api.py", line 206, in <module>\n  File "/cygdrive/c/web2py/gluon/globals.py", line 417, in <lambda>\n    self._caller = lambda f: f()\n  File "/cygdrive/c/web2py/applications/init/controllers/api.py", line 70, in get_best_posts\n    posts.append(r)\nNameError: global name \'r\' is not defined\n'
p11
s.